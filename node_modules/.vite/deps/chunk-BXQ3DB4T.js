// node_modules/nanostores/task/index.js
var tasks = 0;
var resolves = [];
function startTask() {
  tasks += 1;
  return () => {
    tasks -= 1;
    if (tasks === 0) {
      let prevResolves = resolves;
      resolves = [];
      for (let i of prevResolves)
        i();
    }
  };
}
function task(cb) {
  let endTask = startTask();
  return cb().finally(endTask);
}
function allTasks() {
  if (tasks === 0) {
    return Promise.resolve();
  } else {
    return new Promise((resolve) => {
      resolves.push(resolve);
    });
  }
}
function cleanTasks() {
  tasks = 0;
}

// node_modules/nanostores/action/index.js
var lastAction = Symbol();
var actionId = Symbol();
var uid = 0;
var doAction = ($store, actionName, cb, args) => {
  let id = ++uid;
  let tracker = { ...$store };
  tracker.set = (...setArgs) => {
    $store[lastAction] = actionName;
    $store[actionId] = id;
    $store.set(...setArgs);
    delete $store[lastAction];
    delete $store[actionId];
  };
  if ($store.setKey) {
    tracker.setKey = (...setArgs) => {
      $store[lastAction] = actionName;
      $store[actionId] = id;
      $store.setKey(...setArgs);
      delete $store[lastAction];
      delete $store[actionId];
    };
  }
  let onError, onEnd;
  if ($store.action) {
    ;
    [onError, onEnd] = $store.action(id, actionName, args);
  }
  let result = cb(tracker, ...args);
  if (result instanceof Promise) {
    let endTask = startTask();
    return result.catch((error) => {
      if (onError)
        onError(error);
      throw error;
    }).finally(() => {
      endTask();
      if (onEnd)
        onEnd();
    });
  }
  if (onEnd)
    onEnd();
  return result;
};
var action = ($store, actionName, cb) => (...args) => doAction($store, actionName, cb, args);

// node_modules/nanostores/clean-stores/index.js
var clean = Symbol("clean");
var cleanStores = (...stores) => {
  if (false) {
    throw new Error(
      "cleanStores() can be used only during development or tests"
    );
  }
  cleanTasks();
  for (let $store of stores) {
    if ($store) {
      if ($store.mocked)
        delete $store.mocked;
      if ($store[clean])
        $store[clean]();
    }
  }
};

// node_modules/nanostores/atom/index.js
var listenerQueue = [];
var atom = (initialValue, level) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    l: level || 0,
    lc: 0,
    listen(listener, listenerLevel) {
      $atom.lc = listeners.push(listener, listenerLevel || $atom.l) / 2;
      return () => {
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 2);
          if (!--$atom.lc)
            $atom.off();
        }
      };
    },
    notify(changedKey) {
      let runListenerQueue = !listenerQueue.length;
      for (let i = 0; i < listeners.length; i += 2) {
        listenerQueue.push(
          listeners[i],
          listeners[i + 1],
          $atom.value,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (let i = 0; i < listenerQueue.length; i += 4) {
          let skip;
          for (let j = i + 1; !skip && (j += 4) < listenerQueue.length; ) {
            if (listenerQueue[j] < listenerQueue[i + 1]) {
              skip = listenerQueue.push(
                listenerQueue[i],
                listenerQueue[i + 1],
                listenerQueue[i + 2],
                listenerQueue[i + 3]
              );
            }
          }
          if (!skip) {
            listenerQueue[i](listenerQueue[i + 2], listenerQueue[i + 3]);
          }
        }
        listenerQueue.length = 0;
      }
    },
    off() {
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    set(data) {
      if ($atom.value !== data) {
        $atom.value = data;
        $atom.notify();
      }
    },
    subscribe(listener, listenerLevel) {
      let unbind = $atom.listen(listener, listenerLevel);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// node_modules/nanostores/lifecycle/index.js
var START = 0;
var STOP = 1;
var SET = 2;
var NOTIFY = 3;
var MOUNT = 5;
var UNMOUNT = 6;
var ACTION = 7;
var REVERT_MUTATION = 10;
var on = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var onStart = ($store, listener) => on($store, listener, START, (runListeners) => {
  let originListen = $store.listen;
  $store.listen = (arg) => {
    if (!$store.lc && !$store.starting) {
      $store.starting = true;
      runListeners();
      delete $store.starting;
    }
    return originListen(arg);
  };
  return () => {
    $store.listen = originListen;
  };
});
var onStop = ($store, listener) => on($store, listener, STOP, (runListeners) => {
  let originOff = $store.off;
  $store.off = () => {
    runListeners();
    originOff();
  };
  return () => {
    $store.off = originOff;
  };
});
var onSet = ($store, listener) => on($store, listener, SET, (runListeners) => {
  let originSet = $store.set;
  let originSetKey = $store.setKey;
  if ($store.setKey) {
    $store.setKey = (changed, changedValue) => {
      let isAborted;
      let abort = () => {
        isAborted = true;
      };
      runListeners({
        abort,
        changed,
        newValue: { ...$store.value, [changed]: changedValue }
      });
      if (!isAborted)
        return originSetKey(changed, changedValue);
    };
  }
  $store.set = (newValue) => {
    let isAborted;
    let abort = () => {
      isAborted = true;
    };
    runListeners({ abort, newValue });
    if (!isAborted)
      return originSet(newValue);
  };
  return () => {
    $store.set = originSet;
    $store.setKey = originSetKey;
  };
});
var onNotify = ($store, listener) => on($store, listener, NOTIFY, (runListeners) => {
  let originNotify = $store.notify;
  $store.notify = (changed) => {
    let isAborted;
    let abort = () => {
      isAborted = true;
    };
    runListeners({ abort, changed });
    if (!isAborted)
      return originNotify(changed);
  };
  return () => {
    $store.notify = originNotify;
  };
});
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = ($store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy)
      $store.events[UNMOUNT].push(destroy);
  };
  return on($store, listener, MOUNT, (runListeners) => {
    let originListen = $store.listen;
    $store.listen = (...args) => {
      if (!$store.lc && !$store.active) {
        $store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = $store.off;
    $store.events[UNMOUNT] = [];
    $store.off = () => {
      originOff();
      setTimeout(() => {
        if ($store.active && !$store.lc) {
          $store.active = false;
          for (let destroy of $store.events[UNMOUNT])
            destroy();
          $store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = $store[clean];
      $store[clean] = () => {
        for (let destroy of $store.events[UNMOUNT])
          destroy();
        $store.events[UNMOUNT] = [];
        $store.active = false;
        originClean();
      };
    }
    return () => {
      $store.listen = originListen;
      $store.off = originOff;
    };
  });
};
var onAction = ($store, listener) => on($store, listener, ACTION, (runListeners) => {
  let errorListeners = {};
  let endListeners = {};
  let originAction = $store.action;
  $store.action = (id, actionName, args) => {
    runListeners({
      actionName,
      args,
      id,
      onEnd: (l) => {
        (endListeners[id] || (endListeners[id] = [])).push(l);
      },
      onError: (l) => {
        (errorListeners[id] || (errorListeners[id] = [])).push(l);
      }
    });
    return [
      (error) => {
        if (errorListeners[id]) {
          for (let l of errorListeners[id])
            l({ error });
        }
      },
      () => {
        if (endListeners[id]) {
          for (let l of endListeners[id])
            l();
          delete errorListeners[id];
          delete endListeners[id];
        }
      }
    ];
  };
  return () => {
    $store.action = originAction;
  };
});

// node_modules/nanostores/computed/index.js
var computed = (stores, cb) => {
  if (!Array.isArray(stores))
    stores = [stores];
  let diamondArgs;
  let run = () => {
    let args = stores.map(($store) => $store.get());
    if (diamondArgs === void 0 || args.some((arg, i) => arg !== diamondArgs[i])) {
      diamondArgs = args;
      $computed.set(cb(...args));
    }
  };
  let $computed = atom(void 0, Math.max(...stores.map((s) => s.l)) + 1);
  onMount($computed, () => {
    let unbinds = stores.map(($store) => $store.listen(run, $computed.l));
    run();
    return () => {
      for (let unbind of unbinds)
        unbind();
    };
  });
  return $computed;
};

// node_modules/nanostores/deep-map/path.js
function getPath(obj, path) {
  let allKeys = getAllKeysFromPath(path);
  let res = obj;
  for (let key of allKeys) {
    if (res === void 0) {
      break;
    }
    res = res[key];
  }
  return res;
}
function setPath(obj, path, value) {
  return setByKey(obj != null ? obj : {}, getAllKeysFromPath(path), value);
}
function setByKey(obj, splittedKeys, value) {
  let key = splittedKeys[0];
  ensureKey(obj, key, splittedKeys[1]);
  let copy = Array.isArray(obj) ? [...obj] : { ...obj };
  if (splittedKeys.length === 1) {
    if (value === void 0) {
      if (Array.isArray(obj)) {
        copy.splice(key, 1);
      } else {
        delete copy[key];
      }
    } else {
      copy[key] = value;
    }
    return copy;
  }
  let newVal = setByKey(obj[key], splittedKeys.slice(1), value);
  obj[key] = newVal;
  return obj;
}
var ARRAY_INDEX = /(.*)\[(\d+)\]/;
function getAllKeysFromPath(path) {
  return path.split(".").flatMap((key) => getKeyAndIndicesFromKey(key));
}
function getKeyAndIndicesFromKey(key) {
  if (ARRAY_INDEX.test(key)) {
    let [, keyPart, index] = key.match(ARRAY_INDEX);
    return [...getKeyAndIndicesFromKey(keyPart), index];
  }
  return [key];
}
function ensureKey(obj, key, nextKey) {
  if (key in obj) {
    return;
  }
  let nextKeyAsInt = parseInt(
    nextKey !== null && nextKey !== void 0 ? nextKey : ""
  );
  if (Number.isNaN(nextKeyAsInt)) {
    obj[key] = {};
  } else {
    obj[key] = Array(nextKeyAsInt + 1).fill(void 0);
  }
}

// node_modules/nanostores/deep-map/index.js
function deepMap(initial = {}) {
  let $deepMap = atom(initial);
  $deepMap.setKey = (key, value) => {
    if (getPath($deepMap.value, key) !== value) {
      $deepMap.value = { ...setPath($deepMap.value, key, value) };
      $deepMap.notify(key);
    }
  };
  return $deepMap;
}

// node_modules/nanostores/keep-mount/index.js
var keepMount = ($store) => {
  $store.listen(() => {
  });
};

// node_modules/nanostores/listen-keys/index.js
function listenKeys($store, keys, listener) {
  let keysSet = /* @__PURE__ */ new Set([...keys, void 0]);
  return $store.listen((value, changed) => {
    if (keysSet.has(changed)) {
      listener(value, changed);
    }
  });
}

// node_modules/nanostores/map/index.js
var map = (value = {}) => {
  let $map = atom(value);
  $map.setKey = function(key, newValue) {
    if (typeof newValue === "undefined") {
      if (key in $map.value) {
        $map.value = { ...$map.value };
        delete $map.value[key];
        $map.notify(key);
      }
    } else if ($map.value[key] !== newValue) {
      $map.value = {
        ...$map.value,
        [key]: newValue
      };
      $map.notify(key);
    }
  };
  return $map;
};

export {
  startTask,
  task,
  allTasks,
  cleanTasks,
  lastAction,
  actionId,
  action,
  clean,
  cleanStores,
  atom,
  onStart,
  onStop,
  onSet,
  onNotify,
  STORE_UNMOUNT_DELAY,
  onMount,
  onAction,
  computed,
  getPath,
  setPath,
  deepMap,
  keepMount,
  listenKeys,
  map
};
//# sourceMappingURL=chunk-BXQ3DB4T.js.map
