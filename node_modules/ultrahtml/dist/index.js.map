{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["export type Node =\n  | DocumentNode\n  | ElementNode\n  | TextNode\n  | CommentNode\n  | DoctypeNode;\nexport type NodeType =\n  | typeof DOCUMENT_NODE\n  | typeof ELEMENT_NODE\n  | typeof TEXT_NODE\n  | typeof COMMENT_NODE\n  | typeof DOCTYPE_NODE;\nexport interface Location {\n  start: number;\n  end: number;\n}\ninterface BaseNode {\n  type: NodeType;\n  loc: [Location, Location];\n  parent: Node;\n  [key: string]: any;\n}\n\ninterface LiteralNode extends BaseNode {\n  value: string;\n}\n\ninterface ParentNode extends BaseNode {\n  children: Node[];\n}\n\nexport interface DocumentNode extends Omit<ParentNode, \"parent\"> {\n  type: typeof DOCUMENT_NODE;\n  attributes: Record<string, string>;\n  parent: undefined;\n}\n\nexport interface ElementNode extends ParentNode {\n  type: typeof ELEMENT_NODE;\n  name: string;\n  attributes: Record<string, string>;\n}\n\nexport interface TextNode extends LiteralNode {\n  type: typeof TEXT_NODE;\n}\n\nexport interface CommentNode extends LiteralNode {\n  type: typeof COMMENT_NODE;\n}\n\nexport interface DoctypeNode extends LiteralNode {\n  type: typeof DOCTYPE_NODE;\n}\n\nexport const DOCUMENT_NODE = 0;\nexport const ELEMENT_NODE = 1;\nexport const TEXT_NODE = 2;\nexport const COMMENT_NODE = 3;\nexport const DOCTYPE_NODE = 4;\n\nexport function h(\n  type: any,\n  props: null | Record<string, any> = {},\n  ...children: any[]\n) {\n  const vnode: ElementNode = {\n    type: ELEMENT_NODE,\n    name: typeof type === \"function\" ? type.name : type,\n    attributes: props || {},\n    children: children.map((child) =>\n      typeof child === \"string\"\n        ? { type: TEXT_NODE, value: escapeHTML(String(child)) }\n        : child\n    ),\n    parent: undefined as any,\n    loc: [] as any,\n  };\n  if (typeof type === \"function\") {\n    __unsafeRenderFn(vnode, type);\n  }\n  return vnode;\n}\nexport const Fragment = Symbol(\"Fragment\");\n\nconst VOID_TAGS = new Set<string>([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"keygen\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n]);\nconst RAW_TAGS = new Set<string>([\"script\", \"style\"]);\nconst SPLIT_ATTRS_RE = /([\\@\\.a-z0-9_\\:\\-]*)\\s*?=?\\s*?(['\"]?)([\\s\\S]*?)\\2\\s+/gim;\nconst DOM_PARSER_RE =\n  /(?:<(\\/?)([a-zA-Z][a-zA-Z0-9\\:-]*)(?:\\s([^>]*?))?((?:\\s*\\/)?)>|(<\\!\\-\\-)([\\s\\S]*?)(\\-\\->)|(<\\!)([\\s\\S]*?)(>))/gm;\n\nfunction splitAttrs(str?: string) {\n  let obj: Record<string, string> = {};\n  let token: any;\n  if (str) {\n    SPLIT_ATTRS_RE.lastIndex = 0;\n    str = \" \" + (str || \"\") + \" \";\n    while ((token = SPLIT_ATTRS_RE.exec(str))) {\n      if (token[0] === \" \") continue;\n      obj[token[1]] = token[3];\n    }\n  }\n  return obj;\n}\n\nexport function parse(input: string | ReturnType<typeof html>): any {\n  let str = typeof input === \"string\" ? input : input.value;\n  let doc: Node,\n    parent: Node,\n    token: any,\n    text,\n    i,\n    bStart,\n    bText,\n    bEnd,\n    tag: Node;\n  const tags: Node[] = [];\n  DOM_PARSER_RE.lastIndex = 0;\n  parent = doc = {\n    type: DOCUMENT_NODE,\n    children: [] as Node[],\n  } as any;\n\n  let lastIndex = 0;\n  function commitTextNode() {\n    text = str.substring(lastIndex, DOM_PARSER_RE.lastIndex - token[0].length);\n    if (text) {\n      (parent as ParentNode).children.push({\n        type: TEXT_NODE,\n        value: text,\n        parent,\n      } as any);\n    }\n  }\n\n  while ((token = DOM_PARSER_RE.exec(str))) {\n    bStart = token[5] || token[8];\n    bText = token[6] || token[9];\n    bEnd = token[7] || token[10];\n    if (RAW_TAGS.has(parent.name) && token[2] !== parent.name) {\n      i = DOM_PARSER_RE.lastIndex - token[0].length;\n      if (parent.children.length > 0) {\n        parent.children[0].value += token[0];\n      }\n      continue;\n    } else if (bStart === \"<!--\") {\n      i = DOM_PARSER_RE.lastIndex - token[0].length;\n      if (RAW_TAGS.has(parent.name)) {\n        continue;\n      }\n      tag = {\n        type: COMMENT_NODE,\n        value: bText,\n        parent: parent,\n        loc: [\n          {\n            start: i,\n            end: i + bStart.length,\n          },\n          {\n            start: DOM_PARSER_RE.lastIndex - bEnd.length,\n            end: DOM_PARSER_RE.lastIndex,\n          },\n        ],\n      } as any;\n      tags.push(tag);\n      (tag.parent as any).children.push(tag);\n    } else if (bStart === \"<!\") {\n      i = DOM_PARSER_RE.lastIndex - token[0].length;\n      tag = {\n        type: DOCTYPE_NODE,\n        value: bText,\n        parent: parent,\n        loc: [\n          {\n            start: i,\n            end: i + bStart.length,\n          },\n          {\n            start: DOM_PARSER_RE.lastIndex - bEnd.length,\n            end: DOM_PARSER_RE.lastIndex,\n          },\n        ],\n      };\n      // commitTextNode();\n      tags.push(tag);\n      tag.parent.children.push(tag);\n    } else if (token[1] !== \"/\") {\n      commitTextNode();\n      if (RAW_TAGS.has(parent.name)) {\n        lastIndex = DOM_PARSER_RE.lastIndex;\n        commitTextNode();\n        continue;\n      } else {\n        tag = {\n          type: ELEMENT_NODE,\n          name: token[2] + \"\",\n          attributes: splitAttrs(token[3]),\n          parent,\n          children: [],\n          loc: [\n            {\n              start: DOM_PARSER_RE.lastIndex - token[0].length,\n              end: DOM_PARSER_RE.lastIndex,\n            },\n          ] as any,\n        };\n        tags.push(tag);\n        tag.parent.children.push(tag);\n        if (\n          (token[4] && token[4].indexOf(\"/\") > -1) ||\n          VOID_TAGS.has(tag.name)\n        ) {\n          tag.loc[1] = tag.loc[0];\n          tag.isSelfClosingTag = true;\n        } else {\n          parent = tag;\n        }\n      }\n    } else {\n      commitTextNode();\n      // Close parent node if end-tag matches\n      if (token[2] + \"\" === parent.name) {\n        tag = parent;\n        parent = tag.parent!;\n        tag.loc.push({\n          start: DOM_PARSER_RE.lastIndex - token[0].length,\n          end: DOM_PARSER_RE.lastIndex,\n        });\n        text = str.substring(tag.loc[0].end, tag.loc[1].start);\n        if (tag.children.length === 0) {\n          tag.children.push({\n            type: TEXT_NODE,\n            value: text,\n            parent,\n          });\n        }\n      }\n      // account for abuse of self-closing tags when an end-tag is also provided:\n      else if (\n        token[2] + \"\" === tags[tags.length - 1].name &&\n        tags[tags.length - 1].isSelfClosingTag === true\n      ) {\n        tag = tags[tags.length - 1];\n        tag.loc.push({\n          start: DOM_PARSER_RE.lastIndex - token[0].length,\n          end: DOM_PARSER_RE.lastIndex,\n        });\n      }\n    }\n    lastIndex = DOM_PARSER_RE.lastIndex;\n  }\n  text = str.slice(lastIndex);\n  parent.children.push({\n    type: TEXT_NODE,\n    value: text,\n    parent,\n  });\n  return doc;\n}\n\nexport interface Visitor {\n  (node: Node, parent?: Node, index?: number): void | Promise<void>;\n}\n\nexport interface VisitorSync {\n  (node: Node, parent?: Node, index?: number): void;\n}\n\nclass Walker {\n  constructor(private callback: Visitor) {}\n  async visit(node: Node, parent?: Node, index?: number): Promise<void> {\n    await this.callback(node, parent, index);\n    if (Array.isArray(node.children)) {\n      let promises: Promise<void>[] = [];\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        promises.push(this.visit(child, node, i));\n      }\n      await Promise.all(promises);\n    }\n  }\n}\n\nclass WalkerSync {\n  constructor(private callback: VisitorSync) {}\n  visit(node: Node, parent?: Node, index?: number): void {\n    this.callback(node, parent, index);\n    if (Array.isArray(node.children)) {\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        this.visit(child, node, i);\n      }\n    }\n  }\n}\n\nconst HTMLString = Symbol(\"HTMLString\");\nconst AttrString = Symbol(\"AttrString\");\nexport const RenderFn = Symbol(\"RenderFn\");\nfunction mark(str: string, tags: symbol[] = [HTMLString]): { value: string } {\n  const v = { value: str };\n  for (const tag of tags) {\n    Object.defineProperty(v, tag, {\n      value: true,\n      enumerable: false,\n      writable: false,\n    });\n  }\n  return v;\n}\n\nexport function __unsafeHTML(str: string) {\n  return mark(str);\n}\nexport function __unsafeRenderFn(\n  node: ElementNode,\n  fn: (props: Record<string, any>, ...children: Node[]) => Node\n) {\n  Object.defineProperty(node, RenderFn, {\n    value: fn,\n    enumerable: false,\n  });\n  return node;\n}\n\nconst ESCAPE_CHARS: Record<string, string> = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n};\nfunction escapeHTML(str: string): string {\n  return str.replace(/[&<>]/g, (c) => ESCAPE_CHARS[c] || c);\n}\nexport function attrs(attributes: Record<string, string>) {\n  let attrStr = \"\";\n  for (const [key, value] of Object.entries(attributes)) {\n    attrStr += ` ${key}=\"${value}\"`;\n  }\n  return mark(attrStr, [HTMLString, AttrString]);\n}\nexport function html(tmpl: TemplateStringsArray, ...vals: any[]) {\n  let buf = \"\";\n  for (let i = 0; i < tmpl.length; i++) {\n    buf += tmpl[i];\n    const expr = vals[i];\n    if (buf.endsWith(\"...\") && expr && typeof expr === \"object\") {\n      buf = buf.slice(0, -3).trimEnd();\n      buf += attrs(expr).value;\n    } else if (expr && expr[AttrString]) {\n      buf = buf.trimEnd();\n      buf += expr.value;\n    } else if (expr && expr[HTMLString]) {\n      buf += expr.value;\n    } else if (typeof expr === \"string\") {\n      buf += escapeHTML(expr);\n    } else if (expr || expr === 0) {\n      buf += String(expr);\n    }\n  }\n  return mark(buf);\n}\n\nexport function walk(node: Node, callback: Visitor): Promise<void> {\n  const walker = new Walker(callback);\n  return walker.visit(node);\n}\n\nexport function walkSync(node: Node, callback: VisitorSync): void {\n  const walker = new WalkerSync(callback);\n  return walker.visit(node);\n}\n\nfunction canSelfClose(node: Node): boolean {\n  if (node.children.length === 0) {\n    let n: Node | undefined = node;\n    while (n = n.parent) {\n      if (n.name === 'svg') return true;\n    }\n  }\n  return false;\n}\n\n\nasync function renderElement(node: Node): Promise<string> {\n  const { name, attributes = {} } = node;\n  const children = await Promise.all(\n    node.children.map((child: Node) => render(child))\n  ).then((res) => res.join(\"\"));\n  if (RenderFn in node) {\n    const value = await (node as any)[RenderFn](attributes, mark(children));\n    if (value && (value as any)[HTMLString]) return value.value;\n    return escapeHTML(String(value));\n  }\n  if (name === Fragment) return children;\n  const isSelfClosing = canSelfClose(node);\n  if (isSelfClosing || VOID_TAGS.has(name)) {\n    return `<${node.name}${attrs(attributes).value}${isSelfClosing ? ' /' : ''}>`;\n  }\n  return `<${node.name}${attrs(attributes).value}>${children}</${node.name}>`;\n}\n\nfunction renderElementSync(node: Node): string {\n  const { name, attributes = {} } = node;\n  const children = node.children.map((child: Node) => renderSync(child)).join(\"\");\n  if (RenderFn in node) {\n    const value = (node as any)[RenderFn](attributes, mark(children));\n    if (value && (value as any)[HTMLString]) return value.value;\n    return escapeHTML(String(value));\n  }\n  if (name === Fragment) return children;\n  const isSelfClosing = canSelfClose(node);\n  if (isSelfClosing || VOID_TAGS.has(name)) {\n    return `<${node.name}${attrs(attributes).value}${isSelfClosing ? ' /' : ''}>`;\n  }\n  return `<${node.name}${attrs(attributes).value}>${children}</${node.name}>`;\n}\n\nexport function renderSync(node: Node): string {\n  switch (node.type) {\n    case DOCUMENT_NODE:\n      return node.children.map((child: Node) => renderSync(child)).join(\"\");\n    case ELEMENT_NODE:\n      return renderElementSync(node);\n    case TEXT_NODE:\n      return `${node.value}`;\n    case COMMENT_NODE:\n      return `<!--${node.value}-->`;\n    case DOCTYPE_NODE:\n      return `<!${node.value}>`;\n  }\n}\n\nexport async function render(node: Node): Promise<string> {\n  switch (node.type) {\n    case DOCUMENT_NODE:\n      return Promise.all(\n        node.children.map((child: Node) => render(child))\n      ).then((res) => res.join(\"\"));\n    case ELEMENT_NODE:\n      return renderElement(node);\n    case TEXT_NODE:\n      return `${node.value}`;\n    case COMMENT_NODE:\n      return `<!--${node.value}-->`;\n    case DOCTYPE_NODE:\n      return `<!${node.value}>`;\n  }\n}\n\nexport interface Transformer {\n  (node: Node): Node | Promise<Node>;\n}\n\nexport async function transform(\n  markup: string | Node,\n  transformers: Transformer[] = []\n): Promise<string> {\n  if (!Array.isArray(transformers)) {\n    throw new Error(\n      `Invalid second argument for \\`transform\\`! Expected \\`Transformer[]\\` but got \\`${typeof transformers}\\``\n    );\n  }\n  const doc = typeof markup === \"string\" ? parse(markup) : markup;\n  let newDoc = doc;\n  for (const t of transformers) {\n    newDoc = await t(newDoc);\n  }\n  return render(newDoc);\n}\n"],
  "mappings": "AAuDO,IAAMA,EAAgB,EAChBC,EAAe,EACfC,EAAY,EACZC,EAAe,EACfC,EAAe,EAErB,SAASC,EACdC,EACAC,EAAoC,CAAC,KAClCC,EACH,CACA,IAAMC,EAAqB,CACzB,KAAM,EACN,KAAM,OAAOH,GAAS,WAAaA,EAAK,KAAOA,EAC/C,WAAYC,GAAS,CAAC,EACtB,SAAUC,EAAS,IAAKE,GACtB,OAAOA,GAAU,SACb,CAAE,KAAM,EAAW,MAAOC,EAAW,OAAOD,CAAK,CAAC,CAAE,EACpDA,CACN,EACA,OAAQ,OACR,IAAK,CAAC,CACR,EACA,OAAI,OAAOJ,GAAS,YAClBM,EAAiBH,EAAOH,CAAI,EAEvBG,CACT,CACO,IAAMI,EAAW,OAAO,UAAU,EAEnCC,EAAY,IAAI,IAAY,CAChC,OACA,OACA,KACA,MACA,QACA,KACA,MACA,QACA,SACA,OACA,OACA,QACA,SACA,QACA,KACF,CAAC,EACKC,EAAW,IAAI,IAAY,CAAC,SAAU,OAAO,CAAC,EAC9CC,EAAiB,0DACjBC,EACJ,kHAEF,SAASC,EAAWC,EAAc,CAChC,IAAIC,EAA8B,CAAC,EAC/BC,EACJ,GAAIF,EAGF,IAFAH,EAAe,UAAY,EAC3BG,EAAM,KAAOA,GAAO,IAAM,IAClBE,EAAQL,EAAe,KAAKG,CAAG,GACjCE,EAAM,KAAO,MACjBD,EAAIC,EAAM,IAAMA,EAAM,IAG1B,OAAOD,CACT,CAEO,SAASE,EAAMC,EAA8C,CAClE,IAAIJ,EAAM,OAAOI,GAAU,SAAWA,EAAQA,EAAM,MAChDC,EACFC,EACAJ,EACAK,EACAC,EACAC,EACAC,EACAC,EACAC,EACIC,EAAe,CAAC,EACtBf,EAAc,UAAY,EAC1BQ,EAASD,EAAM,CACb,KAAM,EACN,SAAU,CAAC,CACb,EAEA,IAAIS,EAAY,EAChB,SAASC,GAAiB,CACxBR,EAAOP,EAAI,UAAUc,EAAWhB,EAAc,UAAYI,EAAM,GAAG,MAAM,EACrEK,GACDD,EAAsB,SAAS,KAAK,CACnC,KAAM,EACN,MAAOC,EACP,OAAAD,CACF,CAAQ,CAEZ,CAEA,KAAQJ,EAAQJ,EAAc,KAAKE,CAAG,GAAI,CAIxC,GAHAS,EAASP,EAAM,IAAMA,EAAM,GAC3BQ,EAAQR,EAAM,IAAMA,EAAM,GAC1BS,EAAOT,EAAM,IAAMA,EAAM,IACrBN,EAAS,IAAIU,EAAO,IAAI,GAAKJ,EAAM,KAAOI,EAAO,KAAM,CACzDE,EAAIV,EAAc,UAAYI,EAAM,GAAG,OACnCI,EAAO,SAAS,OAAS,IAC3BA,EAAO,SAAS,GAAG,OAASJ,EAAM,IAEpC,QACF,SAAWO,IAAW,OAAQ,CAE5B,GADAD,EAAIV,EAAc,UAAYI,EAAM,GAAG,OACnCN,EAAS,IAAIU,EAAO,IAAI,EAC1B,SAEFM,EAAM,CACJ,KAAM,EACN,MAAOF,EACP,OAAQJ,EACR,IAAK,CACH,CACE,MAAOE,EACP,IAAKA,EAAIC,EAAO,MAClB,EACA,CACE,MAAOX,EAAc,UAAYa,EAAK,OACtC,IAAKb,EAAc,SACrB,CACF,CACF,EACAe,EAAK,KAAKD,CAAG,EACZA,EAAI,OAAe,SAAS,KAAKA,CAAG,CACvC,SAAWH,IAAW,KACpBD,EAAIV,EAAc,UAAYI,EAAM,GAAG,OACvCU,EAAM,CACJ,KAAM,EACN,MAAOF,EACP,OAAQJ,EACR,IAAK,CACH,CACE,MAAOE,EACP,IAAKA,EAAIC,EAAO,MAClB,EACA,CACE,MAAOX,EAAc,UAAYa,EAAK,OACtC,IAAKb,EAAc,SACrB,CACF,CACF,EAEAe,EAAK,KAAKD,CAAG,EACbA,EAAI,OAAO,SAAS,KAAKA,CAAG,UACnBV,EAAM,KAAO,IAEtB,GADAa,EAAe,EACXnB,EAAS,IAAIU,EAAO,IAAI,EAAG,CAC7BQ,EAAYhB,EAAc,UAC1BiB,EAAe,EACf,QACF,MACEH,EAAM,CACJ,KAAM,EACN,KAAMV,EAAM,GAAK,GACjB,WAAYH,EAAWG,EAAM,EAAE,EAC/B,OAAAI,EACA,SAAU,CAAC,EACX,IAAK,CACH,CACE,MAAOR,EAAc,UAAYI,EAAM,GAAG,OAC1C,IAAKJ,EAAc,SACrB,CACF,CACF,EACAe,EAAK,KAAKD,CAAG,EACbA,EAAI,OAAO,SAAS,KAAKA,CAAG,EAEzBV,EAAM,IAAMA,EAAM,GAAG,QAAQ,GAAG,EAAI,IACrCP,EAAU,IAAIiB,EAAI,IAAI,GAEtBA,EAAI,IAAI,GAAKA,EAAI,IAAI,GACrBA,EAAI,iBAAmB,IAEvBN,EAASM,OAIbG,EAAe,EAEXb,EAAM,GAAK,KAAOI,EAAO,MAC3BM,EAAMN,EACNA,EAASM,EAAI,OACbA,EAAI,IAAI,KAAK,CACX,MAAOd,EAAc,UAAYI,EAAM,GAAG,OAC1C,IAAKJ,EAAc,SACrB,CAAC,EACDS,EAAOP,EAAI,UAAUY,EAAI,IAAI,GAAG,IAAKA,EAAI,IAAI,GAAG,KAAK,EACjDA,EAAI,SAAS,SAAW,GAC1BA,EAAI,SAAS,KAAK,CAChB,KAAM,EACN,MAAOL,EACP,OAAAD,CACF,CAAC,GAKHJ,EAAM,GAAK,KAAOW,EAAKA,EAAK,OAAS,GAAG,MACxCA,EAAKA,EAAK,OAAS,GAAG,mBAAqB,KAE3CD,EAAMC,EAAKA,EAAK,OAAS,GACzBD,EAAI,IAAI,KAAK,CACX,MAAOd,EAAc,UAAYI,EAAM,GAAG,OAC1C,IAAKJ,EAAc,SACrB,CAAC,GAGLgB,EAAYhB,EAAc,SAC5B,CACA,OAAAS,EAAOP,EAAI,MAAMc,CAAS,EAC1BR,EAAO,SAAS,KAAK,CACnB,KAAM,EACN,MAAOC,EACP,OAAAD,CACF,CAAC,EACMD,CACT,CAUA,IAAMW,EAAN,KAAa,CACX,YAAoBC,EAAmB,CAAnB,cAAAA,CAAoB,CACxC,MAAM,MAAMC,EAAYZ,EAAea,EAA+B,CAEpE,GADA,MAAM,KAAK,SAASD,EAAMZ,EAAQa,CAAK,EACnC,MAAM,QAAQD,EAAK,QAAQ,EAAG,CAChC,IAAIE,EAA4B,CAAC,EACjC,QAAS,EAAI,EAAG,EAAIF,EAAK,SAAS,OAAQ,IAAK,CAC7C,IAAM3B,EAAQ2B,EAAK,SAAS,GAC5BE,EAAS,KAAK,KAAK,MAAM7B,EAAO2B,EAAM,CAAC,CAAC,CAC1C,CACA,MAAM,QAAQ,IAAIE,CAAQ,CAC5B,CACF,CACF,EAEMC,EAAN,KAAiB,CACf,YAAoBJ,EAAuB,CAAvB,cAAAA,CAAwB,CAC5C,MAAMC,EAAYZ,EAAea,EAAsB,CAErD,GADA,KAAK,SAASD,EAAMZ,EAAQa,CAAK,EAC7B,MAAM,QAAQD,EAAK,QAAQ,EAC7B,QAASV,EAAI,EAAGA,EAAIU,EAAK,SAAS,OAAQV,IAAK,CAC7C,IAAMjB,EAAQ2B,EAAK,SAASV,GAC5B,KAAK,MAAMjB,EAAO2B,EAAMV,CAAC,CAC3B,CAEJ,CACF,EAEMc,EAAa,OAAO,YAAY,EAChCC,EAAa,OAAO,YAAY,EACzBC,EAAW,OAAO,UAAU,EACzC,SAASC,EAAKzB,EAAaa,EAAiB,CAACS,CAAU,EAAsB,CAC3E,IAAMI,EAAI,CAAE,MAAO1B,CAAI,EACvB,QAAWY,KAAOC,EAChB,OAAO,eAAea,EAAGd,EAAK,CAC5B,MAAO,GACP,WAAY,GACZ,SAAU,EACZ,CAAC,EAEH,OAAOc,CACT,CAEO,SAASC,EAAa3B,EAAa,CACxC,OAAOyB,EAAKzB,CAAG,CACjB,CACO,SAASP,EACdyB,EACAU,EACA,CACA,cAAO,eAAeV,EAAMM,EAAU,CACpC,MAAOI,EACP,WAAY,EACd,CAAC,EACMV,CACT,CAEA,IAAMW,EAAuC,CAC3C,IAAK,QACL,IAAK,OACL,IAAK,MACP,EACA,SAASrC,EAAWQ,EAAqB,CACvC,OAAOA,EAAI,QAAQ,SAAW8B,GAAMD,EAAaC,IAAMA,CAAC,CAC1D,CACO,SAASC,EAAMC,EAAoC,CACxD,IAAIC,EAAU,GACd,OAAW,CAACC,EAAKC,CAAK,IAAK,OAAO,QAAQH,CAAU,EAClDC,GAAW,IAAIC,MAAQC,KAEzB,OAAOV,EAAKQ,EAAS,CAACX,EAAYC,CAAU,CAAC,CAC/C,CACO,SAASa,EAAKC,KAA+BC,EAAa,CAC/D,IAAIC,EAAM,GACV,QAAS/B,EAAI,EAAGA,EAAI6B,EAAK,OAAQ7B,IAAK,CACpC+B,GAAOF,EAAK7B,GACZ,IAAMgC,EAAOF,EAAK9B,GACd+B,EAAI,SAAS,KAAK,GAAKC,GAAQ,OAAOA,GAAS,UACjDD,EAAMA,EAAI,MAAM,EAAG,EAAE,EAAE,QAAQ,EAC/BA,GAAOR,EAAMS,CAAI,EAAE,OACVA,GAAQA,EAAKjB,IACtBgB,EAAMA,EAAI,QAAQ,EAClBA,GAAOC,EAAK,OACHA,GAAQA,EAAKlB,GACtBiB,GAAOC,EAAK,MACH,OAAOA,GAAS,SACzBD,GAAO/C,EAAWgD,CAAI,GACbA,GAAQA,IAAS,KAC1BD,GAAO,OAAOC,CAAI,EAEtB,CACA,OAAOf,EAAKc,CAAG,CACjB,CAEO,SAASE,EAAKvB,EAAYD,EAAkC,CAEjE,OADe,IAAID,EAAOC,CAAQ,EACpB,MAAMC,CAAI,CAC1B,CAEO,SAASwB,EAASxB,EAAYD,EAA6B,CAEhE,OADe,IAAII,EAAWJ,CAAQ,EACxB,MAAMC,CAAI,CAC1B,CAEA,SAASyB,EAAazB,EAAqB,CACzC,GAAIA,EAAK,SAAS,SAAW,EAAG,CAC9B,IAAI0B,EAAsB1B,EAC1B,KAAO0B,EAAIA,EAAE,QACX,GAAIA,EAAE,OAAS,MAAO,MAAO,EAEjC,CACA,MAAO,EACT,CAGA,eAAeC,EAAc3B,EAA6B,CACxD,GAAM,CAAE,KAAA4B,EAAM,WAAAd,EAAa,CAAC,CAAE,EAAId,EAC5B7B,EAAW,MAAM,QAAQ,IAC7B6B,EAAK,SAAS,IAAK3B,GAAgBwD,EAAOxD,CAAK,CAAC,CAClD,EAAE,KAAMyD,GAAQA,EAAI,KAAK,EAAE,CAAC,EAC5B,GAAIxB,KAAYN,EAAM,CACpB,IAAMiB,EAAQ,MAAOjB,EAAaM,GAAUQ,EAAYP,EAAKpC,CAAQ,CAAC,EACtE,OAAI8C,GAAUA,EAAcb,GAAoBa,EAAM,MAC/C3C,EAAW,OAAO2C,CAAK,CAAC,CACjC,CACA,GAAIW,IAASpD,EAAU,OAAOL,EAC9B,IAAM4D,EAAgBN,EAAazB,CAAI,EACvC,OAAI+B,GAAiBtD,EAAU,IAAImD,CAAI,EAC9B,IAAI5B,EAAK,OAAOa,EAAMC,CAAU,EAAE,QAAQiB,EAAgB,KAAO,MAEnE,IAAI/B,EAAK,OAAOa,EAAMC,CAAU,EAAE,SAAS3C,MAAa6B,EAAK,OACtE,CAEA,SAASgC,EAAkBhC,EAAoB,CAC7C,GAAM,CAAE,KAAA4B,EAAM,WAAAd,EAAa,CAAC,CAAE,EAAId,EAC5B7B,EAAW6B,EAAK,SAAS,IAAK3B,GAAgB4D,EAAW5D,CAAK,CAAC,EAAE,KAAK,EAAE,EAC9E,GAAIiC,KAAYN,EAAM,CACpB,IAAMiB,EAASjB,EAAaM,GAAUQ,EAAYP,EAAKpC,CAAQ,CAAC,EAChE,OAAI8C,GAAUA,EAAcb,GAAoBa,EAAM,MAC/C3C,EAAW,OAAO2C,CAAK,CAAC,CACjC,CACA,GAAIW,IAASpD,EAAU,OAAOL,EAC9B,IAAM4D,EAAgBN,EAAazB,CAAI,EACvC,OAAI+B,GAAiBtD,EAAU,IAAImD,CAAI,EAC9B,IAAI5B,EAAK,OAAOa,EAAMC,CAAU,EAAE,QAAQiB,EAAgB,KAAO,MAEnE,IAAI/B,EAAK,OAAOa,EAAMC,CAAU,EAAE,SAAS3C,MAAa6B,EAAK,OACtE,CAEO,SAASiC,EAAWjC,EAAoB,CAC7C,OAAQA,EAAK,UACN,GACH,OAAOA,EAAK,SAAS,IAAK3B,GAAgB4D,EAAW5D,CAAK,CAAC,EAAE,KAAK,EAAE,MACjE,GACH,OAAO2D,EAAkBhC,CAAI,MAC1B,GACH,MAAO,GAAGA,EAAK,YACZ,GACH,MAAO,OAAOA,EAAK,eAChB,GACH,MAAO,KAAKA,EAAK,SAEvB,CAEA,eAAsB6B,EAAO7B,EAA6B,CACxD,OAAQA,EAAK,UACN,GACH,OAAO,QAAQ,IACbA,EAAK,SAAS,IAAK3B,GAAgBwD,EAAOxD,CAAK,CAAC,CAClD,EAAE,KAAMyD,GAAQA,EAAI,KAAK,EAAE,CAAC,MACzB,GACH,OAAOH,EAAc3B,CAAI,MACtB,GACH,MAAO,GAAGA,EAAK,YACZ,GACH,MAAO,OAAOA,EAAK,eAChB,GACH,MAAO,KAAKA,EAAK,SAEvB,CAMA,eAAsBkC,EACpBC,EACAC,EAA8B,CAAC,EACd,CACjB,GAAI,CAAC,MAAM,QAAQA,CAAY,EAC7B,MAAM,IAAI,MACR,mFAAmF,OAAOA,KAC5F,EAGF,IAAIC,EADQ,OAAOF,GAAW,SAAWlD,EAAMkD,CAAM,EAAIA,EAEzD,QAAWG,KAAKF,EACdC,EAAS,MAAMC,EAAED,CAAM,EAEzB,OAAOR,EAAOQ,CAAM,CACtB",
  "names": ["DOCUMENT_NODE", "ELEMENT_NODE", "TEXT_NODE", "COMMENT_NODE", "DOCTYPE_NODE", "h", "type", "props", "children", "vnode", "child", "escapeHTML", "__unsafeRenderFn", "Fragment", "VOID_TAGS", "RAW_TAGS", "SPLIT_ATTRS_RE", "DOM_PARSER_RE", "splitAttrs", "str", "obj", "token", "parse", "input", "doc", "parent", "text", "i", "bStart", "bText", "bEnd", "tag", "tags", "lastIndex", "commitTextNode", "Walker", "callback", "node", "index", "promises", "WalkerSync", "HTMLString", "AttrString", "RenderFn", "mark", "v", "__unsafeHTML", "fn", "ESCAPE_CHARS", "c", "attrs", "attributes", "attrStr", "key", "value", "html", "tmpl", "vals", "buf", "expr", "walk", "walkSync", "canSelfClose", "n", "renderElement", "name", "render", "res", "isSelfClosing", "renderElementSync", "renderSync", "transform", "markup", "transformers", "newDoc", "t"]
}
