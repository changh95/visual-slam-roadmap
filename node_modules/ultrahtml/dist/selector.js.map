{
  "version": 3,
  "sources": ["../src/selector.ts", "../node_modules/.pnpm/parsel-js@1.1.2/node_modules/parsel-js/dist/parsel.min.js"],
  "sourcesContent": ["import type { Node } from './index.js';\nimport { ELEMENT_NODE, TEXT_NODE, walkSync } from './index.js';\nimport type { AST, AttributeToken } from 'parsel-js';\nimport { parse, specificity as getSpecificity, specificityToNumber } from 'parsel-js';\n\nexport function specificity(selector: string) {\n    return specificityToNumber(getSpecificity(selector), 10);\n}\n\nexport function matches(node: Node, selector: string): boolean {\n    const match = selectorToMatch(selector);\n    return match(node, node.parent, nthChildIndex(node, node.parent))\n}\n\nexport function querySelector(node: Node, selector: string): Node {\n    const match = selectorToMatch(selector);\n    try {\n        return select(node, (n: Node, parent?: Node, index?: number) => {\n            let m = match(n, parent, index);\n            if (!m) return false;\n            return m;\n        }, { single: true })[0];\n    } catch (e) {\n        if (e instanceof Error) {\n            throw e;\n        }\n        return e as Node;\n    }\n}\n\nexport function querySelectorAll(node: Node, selector: string): Node[] {\n    const match = selectorToMatch(selector);\n    return select(node, (n: Node, parent?: Node, index?: number) => {\n        let m = match(n, parent, index);\n        if (!m) return false;\n        return m;\n    });\n}\n\nexport default querySelectorAll;\n\ninterface Matcher {\n    (n: Node, parent?: Node, index?: number): boolean;\n}\n\nfunction select(node: Node, match: Matcher, opts: { single?: boolean } = { single: false }): Node[] {\n    let nodes: Node[] = [];\n    walkSync(node, (n, parent, index): void => {\n        if (n && n.type !== ELEMENT_NODE) return;\n        if (match(n, parent, index)) {\n            if (opts.single) throw n;\n            nodes.push(n);\n        }\n    })\n    return nodes;\n}\n\nconst getAttributeMatch = (selector: AttributeToken) => {\n    const { operator = '=' } = selector;\n    switch (operator) {\n        case '=': return (a: string, b: string) => a === b;\n        case '~=': return (a: string, b: string) => a.split(/\\s+/g).includes(b);\n        case '|=': return (a: string, b: string) => a.startsWith(b + '-');\n        case '*=': return (a: string, b: string) => a.indexOf(b) > -1;\n        case '$=': return (a: string, b: string) => a.endsWith(b);\n        case '^=': return (a: string, b: string) => a.startsWith(b);\n    }\n    return (a: string, b: string) => false;\n}\n\nconst nthChildIndex = (node: Node, parent?: Node) => parent?.children.filter((n: Node) => n.type === ELEMENT_NODE).findIndex((n: Node) => n === node);\nconst nthChild = (formula: string) => {\n    let [_, A = '1', B = '0'] = /^\\s*(?:(-?(?:\\d+)?)n)?\\s*\\+?\\s*(\\d+)?\\s*$/gm.exec(formula) ?? [];\n    if (A.length === 0) A = '1'\n    const a = Number.parseInt(A === '-' ? '-1' : A);\n    const b = Number.parseInt(B);\n    return (n: number) => (a * n) + b;\n}\nconst lastChild = (node: Node, parent?: Node) => parent?.children.filter((n: Node) => n.type === ELEMENT_NODE).pop() === node;\nconst firstChild = (node: Node, parent?: Node) => parent?.children.filter((n: Node) => n.type === ELEMENT_NODE).shift() === node;\nconst onlyChild = (node: Node, parent?: Node) => parent?.children.filter((n: Node) => n.type === ELEMENT_NODE).length === 1;\n\nconst createMatch = (selector: AST): Matcher => {\n    switch (selector.type) {\n        case 'type': return (node: Node) => {\n            if (selector.content === '*') return true;\n            return node.name === selector.name;\n        }\n        case 'class': return (node: Node) => node.attributes?.class?.split(/\\s+/g).includes(selector.name);\n        case 'id': return (node: Node) => node.attributes?.id === selector.name;\n        case 'pseudo-class': {\n            switch (selector.name) {\n                case 'global': return (...args) => selectorToMatch(parse(selector.argument!)!)(...args);\n                case 'not': return (...args) => !createMatch(selector.subtree!)(...args);\n                case 'is': return (...args) => selectorToMatch(selector.subtree!)(...args);\n                case 'where': return (...args) => selectorToMatch(selector.subtree!)(...args);\n                case 'root': return (node: Node, parent?: Node) => node.type === ELEMENT_NODE && node.name === 'html';\n                case 'empty': return (node: Node) => node.type === ELEMENT_NODE && (node.children.length === 0 || node.children.every((n: Node) => n.type === TEXT_NODE && n.value.trim() === ''));\n                case 'first-child': return (node: Node, parent?: Node) => firstChild(node, parent);\n                case 'last-child': return (node: Node, parent?: Node) => lastChild(node, parent);\n                case 'only-child': return (node: Node, parent?: Node) => onlyChild(node, parent);\n                case 'nth-child': return (node: Node, parent?: Node) => {\n                    const target = nthChildIndex(node, parent) + 1;\n                    if (Number.isNaN(Number(selector.argument))) {\n                        switch (selector.argument) {\n                            case 'odd': return Math.abs(target % 2) == 1;\n                            case 'even': return target % 2 === 0;\n                            default: {\n                                if (!selector.argument) {\n                                    throw new Error(`Unsupported empty nth-child selector!`);\n                                }\n                                const nth = nthChild(selector.argument);\n                                const elements = parent?.children.filter((n: Node) => n.type === ELEMENT_NODE);\n                                const childIndex = nthChildIndex(node, parent) + 1;\n                                for (let i = 0; i < elements.length; i++) {\n                                    let n = nth(i);\n                                    if (n > elements.length) return false;\n                                    if (n === childIndex) return true;\n                                }\n                                return false;\n                            }\n                        }\n                    }\n                    return target === Number(selector.argument);\n                }\n                default: throw new Error(`Unhandled pseudo-class: ${selector.name}!`);\n            }\n        }\n        case 'attribute': return (node: Node) => {\n            let { caseSensitive, name, value } = selector;\n            if (!node.attributes) return false;\n            const attrs = Object.entries(node.attributes as Record<string, string>);\n            for (let [attr, attrVal] of attrs) {\n                if (caseSensitive === 'i') {\n                    value = name.toLowerCase();\n                    attrVal = attr.toLowerCase();\n                }\n                if (attr !== name) continue;\n                if (!value) return true;\n                if ((value[0] === '\"' || value[0] === \"'\") && value[0] === value[value.length - 1]) {\n                    value = JSON.parse(value)\n                }\n                if (value) {\n                    return getAttributeMatch(selector)(attrVal, value);\n                }\n            }\n            return false\n        }\n        case 'universal': return (_: Node) => {\n            return true;\n        }\n        default: {\n            throw new Error(`Unhandled selector: ${selector.type}`)\n        }\n    }\n}\n\nconst selectorToMatch = (sel: string | AST): Matcher => {\n    let selector = typeof sel === 'string' ? parse(sel) : sel;\n    switch (selector?.type) {\n        case 'list': {\n            const matchers = selector.list.map((s: any) => createMatch(s));\n            return (node: Node, parent?: Node, index?: number) => {\n                for (const match of matchers) {\n                    if (match(node, parent!)) return true;\n                }\n                return false;\n            }\n        }\n        case 'compound': {\n            const matchers = selector.list.map((s: any) => createMatch(s));\n            return (node: Node, parent?: Node, index?: number) => {\n                for (const match of matchers) {\n                    if (!match(node, parent!)) return false;\n                }\n                return true;\n            }\n        }\n        case 'complex': {\n            const { left, right, combinator } = selector;\n            const matchLeft = selectorToMatch(left);\n            const matchRight = selectorToMatch(right);\n            let leftMatches = new WeakSet();\n            return (node: Node, parent?: Node, i: number = 0) => {\n                if (matchLeft(node)) {\n                    leftMatches.add(node)\n                } else if (parent && leftMatches.has(parent) && (combinator === ' ')) {\n                    leftMatches.add(node);\n                }\n                if (!matchRight(node)) return false;\n                switch (combinator) {\n                    case ' ': // fall-through\n                    case '>': return parent ? leftMatches.has(parent) : false;\n                    case '~': {\n                        if (!parent) return false;\n                        for (let sibling of parent.children.slice(0, i)) {\n                            if (leftMatches.has(sibling)) return true;\n                        }\n                        return false;\n                    }\n                    case '+': {\n                        if (!parent) return false;\n                        let prevSiblings = parent.children.slice(0, i).filter((el: Node) => el.type === ELEMENT_NODE);\n                        if (prevSiblings.length === 0) return false;\n                        const prev = prevSiblings[prevSiblings.length - 1];\n                        if (!prev) return false;\n                        if (leftMatches.has(prev)) return true;\n                    }\n                    default: return false;\n                }\n            }\n        }\n        default: return createMatch(selector!) as Matcher;\n    }\n}\n", "const e={attribute:/\\[\\s*(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,id:/#(?<name>[-\\w\\P{ASCII}]+)/gu,class:/\\.(?<name>[-\\w\\P{ASCII}]+)/gu,comma:/\\s*,\\s*/g,combinator:/\\s*[\\s>+~]\\s*/g,\"pseudo-element\":/::(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\u00B6*)\\))?/gu,\"pseudo-class\":/:(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\u00B6*)\\))?/gu,universal:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?\\*/gu,type:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)/gu},t=new Set([\"combinator\",\"comma\"]),n=new Set([\"not\",\"is\",\"where\",\"has\",\"matches\",\"-moz-any\",\"-webkit-any\",\"nth-child\",\"nth-last-child\"]),s=/(?<index>[\\dn+-]+)\\s+of\\s+(?<subtree>.+)/,o={\"nth-child\":s,\"nth-last-child\":s},r=t=>{switch(t){case\"pseudo-element\":case\"pseudo-class\":return new RegExp(e[t].source.replace(\"(?<argument>\u00B6*)\",\"(?<argument>.*)\"),\"gu\");default:return e[t]}};function c(e,t){let n=0,s=\"\";for(;t<e.length;t++){const o=e[t];switch(o){case\"(\":++n;break;case\")\":--n}if(s+=o,0===n)return s}return s}function i(n,s=e){if(!n)return[];const o=[n];for(const[e,t]of Object.entries(s))for(let n=0;n<o.length;n++){const s=o[n];if(\"string\"!=typeof s)continue;t.lastIndex=0;const r=t.exec(s);if(!r)continue;const c=r.index-1,i=[],a=r[0],l=s.slice(0,c+1);l&&i.push(l),i.push({...r.groups,type:e,content:a});const u=s.slice(c+a.length+1);u&&i.push(u),o.splice(n,1,...i)}let r=0;for(const e of o)switch(typeof e){case\"string\":throw new Error(`Unexpected sequence ${e} found at index ${r}`);case\"object\":r+=e.content.length,e.pos=[r-e.content.length,r],t.has(e.type)&&(e.content=e.content.trim()||\" \")}return o}const a=/(['\"])([^\\\\\\n]+?)\\1/g,l=/\\\\./g;function u(t,n=e){if(\"\"===(t=t.trim()))return[];const s=[];t=(t=t.replace(l,((e,t)=>(s.push({value:e,offset:t}),\"\uE000\".repeat(e.length))))).replace(a,((e,t,n,o)=>(s.push({value:e,offset:o}),`${t}${\"\uE001\".repeat(n.length)}${t}`)));{let e,n=0;for(;(e=t.indexOf(\"(\",n))>-1;){const o=c(t,e);s.push({value:o,offset:e}),t=`${t.substring(0,e)}(${\"\u00B6\".repeat(o.length-2)})${t.substring(e+o.length)}`,n=e+o.length}}const o=i(t,n),u=new Set;for(const e of s.reverse())for(const t of o){const{offset:n,value:s}=e;if(!(t.pos[0]<=n&&n+s.length<=t.pos[1]))continue;const{content:o}=t,r=n-t.pos[0];t.content=o.slice(0,r)+s+o.slice(r+s.length),t.content!==o&&u.add(t)}for(const e of u){const t=r(e.type);if(!t)throw new Error(`Unknown token type: ${e.type}`);t.lastIndex=0;const n=t.exec(e.content);if(!n)throw new Error(`Unable to parse content for ${e.type}: ${e.content}`);Object.assign(e,n.groups)}return o}function f(e,{list:t=!0}={}){if(t&&e.find((e=>\"comma\"===e.type))){const t=[],n=[];for(let s=0;s<e.length;s++)if(\"comma\"===e[s].type){if(0===n.length)throw new Error(\"Incorrect comma at \"+s);t.push(f(n,{list:!1})),n.length=0}else n.push(e[s]);if(0===n.length)throw new Error(\"Trailing comma\");return t.push(f(n,{list:!1})),{type:\"list\",list:t}}for(let t=e.length-1;t>=0;t--){let n=e[t];if(\"combinator\"===n.type){let s=e.slice(0,t),o=e.slice(t+1);return{type:\"complex\",combinator:n.content,left:f(s),right:f(o)}}}switch(e.length){case 0:throw new Error(\"Could not build AST.\");case 1:return e[0];default:return{type:\"compound\",list:[...e]}}}function*p(e,t){switch(e.type){case\"list\":for(let t of e.list)yield*p(t,e);break;case\"complex\":yield*p(e.left,e),yield*p(e.right,e);break;case\"compound\":yield*e.list.map((t=>[t,e]));break;default:yield[e,t]}}function h(e,t,n){if(e)for(const[s,o]of p(e,n))t(s,o)}function m(e,{recursive:t=!0,list:s=!0}={}){const r=u(e);if(!r)return;const c=f(r,{list:s});if(!t)return c;for(const[e]of p(c)){if(\"pseudo-class\"!==e.type||!e.argument)continue;if(!n.has(e.name))continue;let t=e.argument;const s=o[e.name];if(s){const n=s.exec(t);if(!n)continue;Object.assign(e,n.groups),t=n.groups.subtree}t&&Object.assign(e,{subtree:m(t,{recursive:!0,list:!0})})}return c}function g(e){let t;return t=Array.isArray(e)?e:[...p(e)].map((([e])=>e)),t.map((e=>e.content)).join(\"\")}function d(e,t){return t=t||Math.max(...e)+1,e[0]*(t<<1)+e[1]*t+e[2]}function w(e){let t=e;if(\"string\"==typeof t&&(t=m(t,{recursive:!0})),!t)return[];if(\"list\"===t.type&&\"list\"in t){let e=10;const n=t.list.map((t=>{const n=w(t);return e=Math.max(e,...w(t)),n})),s=n.map((t=>d(t,e)));return n[s.indexOf(Math.max(...s))]}const s=[0,0,0];for(const[e]of p(t))switch(e.type){case\"id\":s[0]++;break;case\"class\":case\"attribute\":s[1]++;break;case\"pseudo-element\":case\"type\":s[2]++;break;case\"pseudo-class\":if(\"where\"===e.name)break;if(!n.has(e.name)||!e.subtree){s[1]++;break}w(e.subtree).forEach(((e,t)=>s[t]+=e)),\"nth-child\"!==e.name&&\"nth-last-child\"!==e.name||s[1]++}return s}export{n as RECURSIVE_PSEUDO_CLASSES,o as RECURSIVE_PSEUDO_CLASSES_ARGS,e as TOKENS,t as TRIM_TOKENS,p as flatten,c as gobbleParens,m as parse,w as specificity,d as specificityToNumber,g as stringify,u as tokenize,i as tokenizeBy,h as walk};\n"],
  "mappings": "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",
  "names": ["ELEMENT_NODE", "TEXT_NODE", "walkSync", "e", "t", "n", "s", "o", "r", "c", "i", "a", "l", "u", "f", "m", "e", "t", "s", "u", "c", "f", "n", "o", "d", "e", "t", "w", "m", "n", "s", "specificity", "selector", "d", "w", "matches", "node", "selectorToMatch", "nthChildIndex", "querySelector", "match", "select", "n", "parent", "index", "m", "e", "querySelectorAll", "selector_default", "opts", "nodes", "walkSync", "ELEMENT_NODE", "getAttributeMatch", "operator", "a", "b", "nthChild", "formula", "_", "A", "B", "lastChild", "firstChild", "onlyChild", "createMatch", "_a", "_b", "args", "TEXT_NODE", "target", "nth", "elements", "childIndex", "i", "caseSensitive", "name", "value", "attrs", "attr", "attrVal", "sel", "matchers", "s", "left", "right", "combinator", "matchLeft", "matchRight", "leftMatches", "sibling", "prevSiblings", "el", "prev"]
}
